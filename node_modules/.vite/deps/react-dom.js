import {
  REACT_ELEMENT_TYPE,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  __export,
  __publicField
} from "./chunk-Q7PVTP4P.js";

// packages/react-dom/src/root.ts
var root_exports = {};
__export(root_exports, {
  createRoot: () => createRoot
});

// packages/react-reconciler/src/workTags.ts
var FunctionComponent = 0;
var HostRoot = 3;
var HostComponent = 5;
var HostText = 6;

// packages/react-reconciler/src/fiberFlags.ts
var NoFlags = 0;
var Placement = 1;
var Update = 2;
var ChildDeletion = 4;
var MutationMask = Placement | Update | ChildDeletion;

// packages/react-reconciler/src/fiber.ts
var FiberNode = class {
  constructor(tag, pendingProps, key) {
    __publicField(this, "tag");
    __publicField(this, "pendingProps");
    __publicField(this, "key");
    __publicField(this, "stateNode");
    __publicField(this, "type");
    // 指向树状结构
    __publicField(this, "return");
    __publicField(this, "sibling");
    __publicField(this, "child");
    __publicField(this, "index");
    __publicField(this, "ref");
    // 作为工作单元
    __publicField(this, "memoizedProps");
    __publicField(this, "alternate");
    __publicField(this, "flags");
    __publicField(this, "updateQueue");
    __publicField(this, "subtreeFlags");
    __publicField(this, "memoizedState");
    this.tag = tag;
    this.pendingProps = pendingProps;
    this.key = key;
    this.stateNode = null;
    this.type = null;
    this.return = null;
    this.sibling = null;
    this.child = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.memoizedProps = null;
    this.memoizedState = null;
    this.alternate = null;
    this.flags = NoFlags;
    this.subtreeFlags = NoFlags;
    this.updateQueue = null;
  }
};
var FiberRootNode = class {
  constructor(container, hostRootFiber) {
    __publicField(this, "container");
    __publicField(this, "current");
    __publicField(this, "finishedWork");
    this.container = container;
    this.current = hostRootFiber;
    hostRootFiber.stateNode = this;
    this.finishedWork = null;
  }
};
var createWorkInProgress = (current, pendingProps) => {
  let wip = current.alternate;
  if (wip === null) {
    wip = new FiberNode(current.tag, pendingProps, current.key);
    wip.stateNode = current.stateNode;
    wip.alternate = current;
    current.alternate = wip;
  } else {
    wip.pendingProps = pendingProps;
    wip.flags = NoFlags;
    wip.subtreeFlags = NoFlags;
  }
  wip.type = current.type;
  wip.updateQueue = current.updateQueue;
  wip.child = current.child;
  wip.memoizedProps = current.memoizedProps;
  wip.memoizedState = current.memoizedState;
  return wip;
};
function createFiberFromElement(element) {
  if (element === null || element === void 0) {
    if (__DEV__) {
      console.error("createElement received null or undefined element");
    }
    return null;
  }
  const { type, props, $$typeof } = element;
  if (!$$typeof || $$typeof !== REACT_ELEMENT_TYPE) {
    if (__DEV__) {
      console.error("Invalid React element type", element);
    }
    return null;
  }
  if (type === void 0) {
    if (__DEV__) {
      console.error("Element type is undefined", element);
    }
    return null;
  }
  let fiberTag;
  if (typeof type === "function") {
    fiberTag = FunctionComponent;
  } else if (typeof type === "string") {
    fiberTag = HostComponent;
  } else {
    if (__DEV__) {
      console.error("未实现的type类型", element);
    }
    return null;
  }
  const fiber = new FiberNode(fiberTag, props, null);
  fiber.type = type;
  return fiber;
}

// packages/react-reconciler/src/updateQueue.ts
var createUpdate = (action) => {
  return {
    action,
    next: null
  };
};
var createUpdateQueue = () => {
  return {
    shared: { pending: null },
    dispatch: null
  };
};
var enqueueUpdate = (updateQueue, update) => {
  updateQueue.shared.pending = update;
};
function processUpdateQueue(baseState, updates) {
  let newState = baseState;
  let currentUpdate = updates;
  while (currentUpdate) {
    const action = currentUpdate.action;
    newState = typeof action === "function" ? action(newState) : action;
    currentUpdate = currentUpdate.next;
  }
  return { memoizedState: newState };
}

// packages/react-dom/src/hostConfig.ts
function createInstance(type) {
  const element = document.createElement(type);
  return element;
}
function createTextInstance(content) {
  return document.createTextNode(content);
}
function appendInitialChild(parent, child) {
  parent.appendChild(child);
}
function appendChildToContainer(container, child) {
  container.appendChild(child);
}

// packages/react-reconciler/src/childFibers.ts
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  const fiber = createFiberFromElement(element);
  if (fiber === null) {
    return null;
  }
  fiber.flags |= Placement;
  fiber.return = returnFiber;
  return fiber;
}
function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
  const contentString = content + "";
  const fiber = new FiberNode(HostText, { content: contentString }, null);
  fiber.stateNode = createTextInstance(contentString);
  fiber.flags |= Placement;
  fiber.return = returnFiber;
  return fiber;
}
function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
  let previousNewFiber = null;
  let resultingFirstChild = null;
  for (let i = 0; i < newChild.length; i++) {
    const child = newChild[i];
    if (child === null || child === void 0 || child === false) {
      continue;
    }
    let newFiber = null;
    if (typeof child === "string" || typeof child === "number") {
      newFiber = reconcileSingleTextNode(returnFiber, null, child);
    } else if (typeof child === "object" && child !== null) {
      if (child.$$typeof === REACT_ELEMENT_TYPE) {
        newFiber = createFiberFromElement(child);
      }
    }
    if (newFiber === null) {
      continue;
    }
    newFiber.flags |= Placement;
    newFiber.return = returnFiber;
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    previousNewFiber = newFiber;
  }
  return resultingFirstChild;
}
function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
  if (typeof newChild === "object" && newChild !== null) {
    if (newChild.$$typeof === REACT_ELEMENT_TYPE) {
      return reconcileSingleElement(returnFiber, currentFirstChild, newChild);
    }
  }
  if (Array.isArray(newChild)) {
    return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
  }
  if (typeof newChild === "string" || typeof newChild === "number") {
    return reconcileSingleTextNode(returnFiber, currentFirstChild, newChild);
  }
  if (newChild === null || newChild === void 0) {
    return null;
  }
  if (__DEV__) {
    console.warn("未实现的reconcile类型", newChild);
  }
  return null;
}
var mountChildFibers = reconcileChildFibers;

// packages/shared/internals.ts
var internals = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
var internals_default = internals;

// packages/react-reconciler/src/fiberHooks.ts
var currentlyRenderingFiber = null;
var workInProgressHook = null;
if (!internals_default) {
  throw new Error("internals is undefined");
}
var { currentDispatcher } = internals_default;
function renderWithHooks(wip) {
  currentlyRenderingFiber = wip;
  wip.memoizedProps = null;
  const current = wip.alternate;
  if (current !== null) {
    wip.memoizedState = current.memoizedState;
  } else {
    currentDispatcher.current = HooksDispatcherOnMount;
  }
  const Component = wip.type;
  const props = wip.pendingProps;
  let children;
  try {
    children = Component(props);
  } finally {
    currentlyRenderingFiber = null;
    workInProgressHook = null;
    currentDispatcher.current = null;
  }
  return children;
}
var HooksDispatcherOnMount = {
  useState: mountState
};
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  let memoizedState;
  if (typeof initialState === "function") {
    memoizedState = initialState();
  } else {
    memoizedState = initialState;
  }
  const queue = createUpdateQueue();
  hook.updateQueue = queue;
  const dispatch = (action) => {
    dispatchSetState(
      currentlyRenderingFiber,
      queue,
      action
    );
  };
  queue.dispatch = dispatch;
  return [memoizedState, dispatch];
}
function dispatchSetState(fiber, updateQueue, action) {
  const update = createUpdate(action);
  enqueueUpdate(updateQueue, update);
  scheduleUpdateOnFiber(fiber);
}
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    updateQueue: null,
    next: null
  };
  if (workInProgressHook === null) {
    if (currentlyRenderingFiber === null) {
      throw new Error("请在函数组件内使用hook");
    } else {
      workInProgressHook = hook;
      currentlyRenderingFiber.memoizedState = workInProgressHook;
    }
  } else {
    workInProgressHook.next = hook;
    workInProgressHook = hook;
  }
  return workInProgressHook;
}

// packages/react-reconciler/src/beginWork.ts
function beginWork(wip, renderLanes) {
  switch (wip.tag) {
    case HostRoot:
      return updateHostRoot(wip, renderLanes);
    case HostComponent:
      return updateHostComponent(wip);
    case HostText:
      return null;
    case FunctionComponent:
      return updateFunctionComponent(wip);
    default:
      if (__DEV__) {
        console.warn("beginWork未实现的类型");
      }
      break;
  }
  return null;
}
function updateHostRoot(wip, renderLanes) {
  const baseState = wip.memoizedState;
  const updateQueue = wip.updateQueue;
  const pending = updateQueue.shared.pending;
  updateQueue.shared.pending = null;
  const { memoizedState } = processUpdateQueue(baseState, pending);
  wip.memoizedState = memoizedState;
  const nextChildren = wip.memoizedState;
  reconcileChildren(wip, nextChildren);
  return wip.child;
}
function updateHostComponent(wip) {
  if (!wip.stateNode) {
    wip.stateNode = createInstance(wip.type);
    for (const prop in wip.pendingProps) {
      if (prop !== "children") {
        wip.stateNode[prop] = wip.pendingProps[prop];
      }
    }
  }
  const nextChildren = wip.pendingProps.children;
  reconcileChildren(wip, nextChildren);
  return wip.child;
}
function reconcileChildren(wip, children) {
  const current = wip.alternate;
  if (current !== null) {
    wip.child = reconcileChildFibers(wip, current == null ? void 0 : current.child, children);
  } else {
    wip.child = mountChildFibers(wip, null, children);
  }
}
function updateFunctionComponent(wip) {
  const nextProps = wip.pendingProps;
  const nextChildren = renderWithHooks(wip);
  reconcileChildren(wip, nextChildren);
  return wip.child;
}

// packages/react-reconciler/src/completeWork.ts
var completeWork = (wip) => {
  const newProps = wip.pendingProps;
  const current = wip.alternate;
  switch (wip.tag) {
    case HostComponent:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createInstance(wip.type);
        appendAllChildren(instance, wip);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostText:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createTextInstance(newProps.content);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostRoot:
      bubbleProperties(wip);
      return null;
    case FunctionComponent:
      bubbleProperties(wip);
      return null;
    default:
      if (__DEV__) {
        console.warn("未处理的completeWork类型", wip);
      }
      return null;
  }
};
function appendAllChildren(parent, wip) {
  let node = wip.child;
  while (node !== null) {
    if (node.tag === HostComponent || node.tag === HostText) {
      if (node.stateNode) {
        appendInitialChild(parent, node.stateNode);
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === wip) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === wip) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}
function bubbleProperties(wip) {
  let subtreeFlags = NoFlags;
  let child = wip.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child.return = wip;
    child = child.sibling;
  }
  wip.subtreeFlags = subtreeFlags;
}

// packages/react-reconciler/src/commitWork.ts
var commitMutationEffects = (finishedWork) => {
  commitMutationEffectsOnFiber(finishedWork);
};
function commitMutationEffectsOnFiber(finishedWork) {
  const flags = finishedWork.flags;
  if ((flags & Placement) !== NoFlags) {
    commitPlacement(finishedWork);
    finishedWork.flags &= ~Placement;
  }
  let child = finishedWork.child;
  while (child !== null) {
    commitMutationEffectsOnFiber(child);
    child = child.sibling;
  }
}
function commitPlacement(finishedWork) {
  if (__DEV__) {
    console.log("执行Placement操作", finishedWork);
  }
  const hostParent = getHostParent(finishedWork);
  if (hostParent !== null) {
    appendPlacementNodeIntoContainer(finishedWork, hostParent);
  }
}
function getHostParent(fiber) {
  let parent = fiber.return;
  while (parent) {
    const parentTag = parent.tag;
    if (parentTag === HostComponent) {
      return parent.stateNode;
    }
    if (parentTag === HostRoot) {
      return parent.stateNode.container;
    }
    parent = parent.return;
  }
  return null;
}
function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
  if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
    appendChildToContainer(hostParent, finishedWork.stateNode);
    return;
  }
  if (finishedWork.tag === FunctionComponent) {
    const child2 = finishedWork.child;
    if (child2 !== null) {
      appendPlacementNodeIntoContainer(child2, hostParent);
    }
    return;
  }
  const child = finishedWork.child;
  if (child !== null) {
    appendPlacementNodeIntoContainer(child, hostParent);
    let sibling = child.sibling;
    while (sibling !== null) {
      appendPlacementNodeIntoContainer(sibling, hostParent);
      sibling = sibling.sibling;
    }
  }
}
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  if (finishedWork === null) {
    return;
  }
  if (__DEV__) {
    console.log("commit阶段开始", finishedWork);
  }
  root.finishedWork = null;
  const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
  if (subtreeHasEffect || rootHasEffect) {
    commitMutationEffects(finishedWork);
    root.current = finishedWork;
  } else {
    root.current = finishedWork;
  }
}

// packages/react-reconciler/src/workLoop.ts
var workInProgressRenderLanes = 0;
var NoLanes = 0;
var workInProgress = null;
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, {});
  workInProgressRenderLanes = NoLanes;
}
function scheduleUpdateOnFiber(fiber) {
  const root = markUpdateFromFiberToRoot(fiber);
  if (root !== null) {
    renderRoot(root);
  }
}
function markUpdateFromFiberToRoot(fiber) {
  let node = fiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  if (node.tag === HostRoot) {
    return node.stateNode;
  }
  return null;
}
function renderRoot(root) {
  prepareFreshStack(root);
  do {
    try {
      workLoop();
      break;
    } catch (e) {
      if (__DEV__) {
        console.warn("workLoop发生错误", e);
      }
      workInProgress = null;
    }
  } while (true);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function workLoop() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(fiber) {
  const next = beginWork(fiber, workInProgressRenderLanes);
  fiber.memoizedProps = fiber.pendingProps;
  if (next === null) {
    completeUnitOfWork(fiber);
  } else {
    workInProgress = next;
  }
}
function completeUnitOfWork(fiber) {
  let node = fiber;
  do {
    completeWork(node);
    const sibling = node.sibling;
    if (sibling !== null) {
      workInProgress = sibling;
      return;
    }
    node = node.return;
    workInProgress = node;
  } while (node !== null);
}

// packages/react-reconciler/src/fiberReconciler.ts
function createContainer(container) {
  const hostRootFiber = new FiberNode(HostRoot, {}, null);
  const root = new FiberRootNode(container, hostRootFiber);
  hostRootFiber.updateQueue = createUpdateQueue();
  return root;
}
function updateContainer(element, root) {
  const hostRootFiber = root.current;
  const update = createUpdate(element);
  enqueueUpdate(hostRootFiber.updateQueue, update);
  scheduleUpdateOnFiber(hostRootFiber);
  return element;
}

// packages/react-dom/src/root.ts
function createRoot(container) {
  const root = createContainer(container);
  return {
    render(element) {
      updateContainer(element, root);
    }
  };
}

// packages/react-dom/index.ts
var react_dom_default = root_exports;
export {
  react_dom_default as default
};
//# sourceMappingURL=react-dom.js.map
