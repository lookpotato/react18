import {
  REACT_ELEMENT_TYPE,
  __export,
  __publicField
} from "./chunk-WZ4VTCNZ.js";

// packages/react-dom/src/root.ts
var root_exports = {};
__export(root_exports, {
  createRoot: () => createRoot
});

// packages/react-reconciler/src/workTags.ts
var FunctionComponent2 = 0;
var HostRoot = 3;
var HostComponent = 5;
var HostText = 6;

// packages/react-reconciler/src/fiberFlags.ts
var NoFlags = 0;
var Placement = 1;
var Update = 2;
var ChildDeletion = 4;
var MutationMask = Placement | Update | ChildDeletion;

// packages/react-reconciler/src/fiber.ts
var FiberNode = class {
  constructor(tag, pendingProps, key) {
    __publicField(this, "tag");
    __publicField(this, "pendingProps");
    __publicField(this, "key");
    __publicField(this, "stateNode");
    __publicField(this, "type");
    // 指向树状结构
    __publicField(this, "return");
    __publicField(this, "sibling");
    __publicField(this, "child");
    __publicField(this, "index");
    __publicField(this, "ref");
    // 作为工作单元
    __publicField(this, "memoizedProps");
    __publicField(this, "alternate");
    __publicField(this, "flags");
    __publicField(this, "updateQueue");
    __publicField(this, "subtreeFlags");
    __publicField(this, "memoizedState");
    this.tag = tag;
    this.pendingProps = pendingProps;
    this.key = key;
    this.stateNode = null;
    this.type = null;
    this.return = null;
    this.sibling = null;
    this.child = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.memoizedProps = null;
    this.memoizedState = null;
    this.alternate = null;
    this.flags = NoFlags;
    this.subtreeFlags = NoFlags;
    this.updateQueue = null;
  }
};
var FiberRootNode = class {
  constructor(container, hostRootFiber) {
    __publicField(this, "container");
    __publicField(this, "current");
    __publicField(this, "finishedWork");
    this.container = container;
    this.current = hostRootFiber;
    hostRootFiber.stateNode = this;
    this.finishedWork = null;
  }
};
var createWorkInProgress = (current, pendingProps) => {
  let wip = current.alternate;
  if (wip === null) {
    wip = new FiberNode(current.tag, pendingProps, current.key);
    wip.stateNode = current.stateNode;
    wip.alternate = current;
    current.alternate = wip;
  } else {
    wip.pendingProps = pendingProps;
    wip.flags = NoFlags;
    wip.subtreeFlags = NoFlags;
  }
  wip.type = current.type;
  wip.updateQueue = current.updateQueue;
  wip.child = current.child;
  wip.memoizedProps = current.memoizedProps;
  wip.memoizedState = current.memoizedState;
  return wip;
};
function createFiberFromElement(element) {
  const { type, key, props } = element;
  let fiberTag = FunctionComponent2;
  if (typeof type === "string") {
    fiberTag = HostComponent;
  } else if (typeof type !== "function" && __DEV__) {
    console.warn("未实现的type类型", element);
  }
  const fiber = new FiberNode(fiberTag, props, key);
  fiber.type = type;
  return fiber;
}

// packages/react-reconciler/src/updateQueue.ts
var createUpdate = (action) => {
  return { action };
};
var createUpdateQueue = () => {
  return {
    shared: { pending: null }
  };
};
var enqueueUpdate = (updateQueue, update) => {
  updateQueue.shared.pending = update;
};
var processUpdateQueue = (baseState, pendingUpdate) => {
  const result = {
    memoizedState: baseState
  };
  if (pendingUpdate !== null) {
    const action = pendingUpdate.action;
    if (action instanceof Function) {
      result.memoizedState = action(baseState);
    } else {
      result.memoizedState = action;
    }
  }
  return result;
};

// packages/react-reconciler/src/childFibers.ts
function ChildReconciler(shouldTrackEffects) {
  function reconcileSingleElement(returnFiber, currentFirstChild, element) {
    const fiber = createFiberFromElement(element);
    fiber.return = returnFiber;
    return fiber;
  }
  function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
    const fiber = new FiberNode(HostText, { content }, null);
    fiber.return = returnFiber;
    return fiber;
  }
  function placeSingleChild(fiber) {
    if (shouldTrackEffects && fiber.alternate === null) {
      fiber.flags |= Placement;
    }
    return fiber;
  }
  return function reconcileChildFibers2(returnFiber, currentFirstChild, newChild) {
    if (typeof newChild === "object" && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(returnFiber, currentFirstChild, newChild)
          );
        default:
          if (__DEV__) {
            console.warn("未实现的reconcile类型", newChild);
          }
          break;
      }
    }
    if (typeof newChild === "string" || typeof newChild === "number") {
      return placeSingleChild(
        reconcileSingleTextNode(returnFiber, currentFirstChild, newChild)
      );
    }
    return null;
  };
}
var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

// packages/react-reconciler/src/beginWork.ts
function beginWork(wip, renderLanes) {
  switch (wip.tag) {
    case HostRoot:
      return updateHostRoot(wip, renderLanes);
    case HostComponent:
      return updateHostComponent(wip);
    case HostText:
      return null;
    case FunctionComponent:
      return updateFunctionComponent(wip);
    default:
      if (__DEV__) {
        console.warn("beginWork未实现的类型");
      }
      break;
  }
  return null;
}
function updateHostRoot(wip, renderLanes) {
  const baseState = wip.memoizedState;
  const updateQueue = wip.updateQueue;
  const pending = updateQueue.shared.pending;
  updateQueue.shared.pending = null;
  const { memoizedState } = processUpdateQueue(baseState, pending);
  wip.memoizedState = memoizedState;
  const nextChildren = wip.memoizedState;
  reconcileChildren(wip, nextChildren);
  return wip.child;
}
function updateHostComponent(wip) {
  const nextProps = wip.pendingProps;
  const nextChildren = nextProps.children;
  reconcileChildren(wip, nextChildren);
  return wip.child;
}
function reconcileChildren(wip, children) {
  const current = wip.alternate;
  if (current !== null) {
    wip.child = reconcileChildFibers(wip, current == null ? void 0 : current.child, children);
  } else {
    wip.child = mountChildFibers(wip, null, children);
  }
}
function updateFunctionComponent(wip) {
  const nextProps = wip.pendingProps;
  const nextChildren = renderWithHooks(wip);
  reconcileChildren(wip, nextChildren);
  return wip.child;
}

// packages/react-dom/src/hostConfig.ts
function createInstance(type) {
  const element = document.createElement(type);
  return element;
}
var appendInitialChild = (parent, child) => {
  parent.appendChild(child);
};
var createTextInstance = (content) => {
  return document.createTextNode(content);
};
var appendChildToContainer = appendInitialChild;

// packages/react-reconciler/src/completeWork.ts
var completeWork = (wip) => {
  const newProps = wip.pendingProps;
  const current = wip.alternate;
  switch (wip.tag) {
    case HostComponent:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createInstance(wip.type);
        appendAllChildren(instance, wip);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostText:
      if (current !== null && wip.stateNode) {
      } else {
        const instance = createTextInstance(newProps.content);
        wip.stateNode = instance;
      }
      bubbleProperties(wip);
      return null;
    case HostRoot:
      bubbleProperties(wip);
      return null;
    case FunctionComponent2:
      bubbleProperties(wip);
      return null;
    default:
      if (__DEV__) {
        console.warn("未处理的completeWork类型", wip);
      }
      return null;
  }
};
function appendAllChildren(parent, wip) {
  let node = wip.child;
  while (node !== null) {
    if (node.tag === HostComponent || node.tag === HostText) {
      if (node.stateNode) {
        appendInitialChild(parent, node.stateNode);
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === wip) {
      return;
    }
    while (node.sibling === null) {
      if (node.return === null || node.return === wip) {
        return;
      }
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
}
function bubbleProperties(wip) {
  let subtreeFlags = NoFlags;
  let child = wip.child;
  while (child !== null) {
    subtreeFlags |= child.subtreeFlags;
    subtreeFlags |= child.flags;
    child.return = wip;
    child = child.sibling;
  }
  wip.subtreeFlags = subtreeFlags;
}

// packages/react-reconciler/src/commitWork.ts
var nextEffect = null;
var commitMutationEffects = (finishedWork) => {
  nextEffect = finishedWork;
  while (nextEffect !== null) {
    const child = nextEffect.child;
    if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags && child !== null) {
      nextEffect = child;
    } else {
      up:
        while (nextEffect !== null) {
          commitMutationEffectsOnFiber(nextEffect);
          const sibling = nextEffect.sibling;
          if (sibling !== null) {
            nextEffect = sibling;
            break up;
          }
          nextEffect = nextEffect.return;
        }
    }
  }
};
function commitMutationEffectsOnFiber(finishedWork) {
  const flags = finishedWork.flags;
  if ((flags & Placement) !== NoFlags) {
    commitPlacement(finishedWork);
    finishedWork.flags &= ~Placement;
  }
}
function commitPlacement(finishedWork) {
  if (__DEV__) {
    console.warn("执行Placement操作", finishedWork);
  }
  const hostParent = getHostParent(finishedWork);
  if (hostParent !== null) {
    appendPlacementNodeIntoContainer(finishedWork, hostParent);
  }
}
function getHostParent(fiber) {
  let parent = fiber.return;
  while (parent) {
    const parentTag = parent.tag;
    if (parentTag === HostComponent) {
      return parent.stateNode;
    }
    if (parentTag === HostRoot) {
      return parent.stateNode.container;
    }
    parent = parent.return;
  }
  if (__DEV__) {
    console.warn("未找到host parent");
  }
  return null;
}
function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
  if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
    appendChildToContainer(hostParent, finishedWork.stateNode);
    return;
  }
  const child = finishedWork.child;
  if (child !== null) {
    appendPlacementNodeIntoContainer(child, hostParent);
    let sibling = child.sibling;
    while (sibling !== null) {
      appendPlacementNodeIntoContainer(sibling, hostParent);
      sibling = sibling.sibling;
    }
  }
}
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  if (finishedWork === null) {
    return;
  }
  if (__DEV__) {
    console.log("commit阶段开始", finishedWork);
  }
  root.finishedWork = null;
  const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
  const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
  if (subtreeHasEffect || rootHasEffect) {
    commitMutationEffects(finishedWork);
    root.current = finishedWork;
  } else {
    root.current = finishedWork;
  }
}

// packages/react-reconciler/src/workLoop.ts
var workInProgressRenderLanes = 0;
var NoLanes = 0;
var workInProgress = null;
function prepareFreshStack(root) {
  workInProgress = createWorkInProgress(root.current, {});
  workInProgressRenderLanes = NoLanes;
}
function scheduleUpdateOnFiber(fiber) {
  const root = markUpdateFromFiberToRoot(fiber);
  if (root !== null) {
    renderRoot(root);
  }
}
function markUpdateFromFiberToRoot(fiber) {
  let node = fiber;
  let parent = node.return;
  while (parent !== null) {
    node = parent;
    parent = node.return;
  }
  if (node.tag === HostRoot) {
    return node.stateNode;
  }
  return null;
}
function renderRoot(root) {
  prepareFreshStack(root);
  do {
    try {
      workLoop();
      break;
    } catch (e) {
      if (__DEV__) {
        console.warn("workLoop发生错误", e);
      }
      workInProgress = null;
    }
  } while (true);
  const finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  commitRoot(root);
}
function workLoop() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
function performUnitOfWork(fiber) {
  const next = beginWork(fiber, workInProgressRenderLanes);
  fiber.memoizedProps = fiber.pendingProps;
  if (next === null) {
    completeUnitOfWork(fiber);
  } else {
    workInProgress = next;
  }
}
function completeUnitOfWork(fiber) {
  let node = fiber;
  do {
    completeWork(node);
    const sibling = node.sibling;
    if (sibling !== null) {
      workInProgress = sibling;
      return;
    }
    node = node.return;
    workInProgress = node;
  } while (node !== null);
}

// packages/react-reconciler/src/fiberReconciler.ts
function createContainer(container) {
  const hostRootFiber = new FiberNode(HostRoot, {}, null);
  const root = new FiberRootNode(container, hostRootFiber);
  hostRootFiber.updateQueue = createUpdateQueue();
  return root;
}
function updateContainer(element, root) {
  const hostRootFiber = root.current;
  const update = createUpdate(element);
  enqueueUpdate(hostRootFiber.updateQueue, update);
  scheduleUpdateOnFiber(hostRootFiber);
  return element;
}

// packages/react-dom/src/root.ts
function createRoot(container) {
  const root = createContainer(container);
  return {
    render(element) {
      updateContainer(element, root);
    }
  };
}

// packages/react-dom/index.ts
var react_dom_default = root_exports;
export {
  react_dom_default as default
};
//# sourceMappingURL=react-dom.js.map
